# リファクタリング

## はじめに

既存のコードを安全に改善する。

リファクタリングの第一歩は、対象コードについてきちんとしたテスト群を作り上げること！

テストをコマンド一つで実行できるようにし、何度も頻繁に走らせること！  
また、結果は一目でわかるようにする（自己診断機能）必要がある。

良いコードかどうかは、変更がどれだけ容易かで決まる

## 原則

**リファクタリング**  
外部から見た時の振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること

**リファクタリングする**  
一連のリファクタリングを適応して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること

絶対に、小さなステップで実行していく。リファクタリングしている時に機能追加・テストの追加をしてはいけない。コードの再構築をするのみ。

**WHY Rafactoring**  
リファクタリングなしでは、ソフトウェアの内部構造は徐々に劣化していく。

CI とリファクタリングは相性が良い。毎日メインブランチへの統合を行う。

## 不吉な匂い

- 良い名前が思いつかないのは、まだ設計が固まっていないということ！

## かたろぐ

### 関数の抽出

- 何をしているのか調べなければわからないコードの断片があるとしたら、「何」をしているかを示す名前の関数として抽出すべき
- 関数が 6 行を超えると、嫌な匂いがし始めている
- 命名は、どうやるかではなく、何をするか

### 変数の抽出

- ロジックは、オブジェクトに与えられた適切な大きさのコンテキストを通じて、他のロジックやデータを共有できる

### 変数のカプセル化

- 広い範囲で利用されるデータを移動したいときは、まずそれをカプセル化して、変数へのアクセスを関数経由にする
- データの変更や参照を監視できる、という明確な利点あり
  - public な変数だと、『飛ばないと参照なのか変更なのかわからない』
- getter の先頭に get をつけるのは気に入らない笑
  - そうよな〜
- **getter に対し、値のコピーを返す、という方法がある！！**
  - リストなどの、非プリミティブな要素に対して有効（？）
  - クライアント側が、たとえその値を変更したとしても、反映されない！
  - よりユーザーにとっても**変更できないことを伝えたければ、レコードのカプセル化**を行う
- コピーやクラスラッパーは、どちらもレコード構造の１段階の深さでしか機能しない

## カプセル化

モジュールとして分割すべきかを決める基準＝システムの他の部分から隠蔽すべき秘密を持っているか。  
データ構造は最も典型的な例。

クラスは情報隠蔽のために設計された。

構造化されたデータは、少し扱いに注意する必要あり。参照時はデータのコピーを返す方法が最も簡単だが、データのコピーに時間がかかる場合がある。その場合でも、一旦影響を測定するべし。  
レコードのカプセル化を再起的に施すのが他の選択肢、手間がかかるが高度に制御可能。

プログラムに変更可能なデータがあれば、とにかくカプセル化したくなる。いつどのようにデータ構造が変更されるかが分かりやすくなるから！

プログラミングの力の源は実のところはデータ構造にある。

テーブルを見せてくれたら、通常フローチャートはいらない。

## 条件分岐について

- 例外的な動作に対するガード節
- ポリモーフィズムによる条件分岐の置き換え

## API のリファクタ

優れた API は、データを更新する関数とデータを参照するだけの関数を明確に分離する。

フラグ引数は好ましくない。  
どの関数呼び出しが使えるか、それをどう呼び出せば良いかを理解するプロセスが煩雑になるため。

## そのほかメモ

- `Date.now()` のような関数は直接呼ばず、ラップするようにする
  - テストが非決定的になってしまうので
- 関数名の中に and とかあるのは不吉な匂い
- 一部の言語では、コンパイル時のスイッチによってアサーションを無効にできる
  - アサーションは有効なコミュニケーション形式にもなる
  - エラーが解消しても消さない派らしい
- コマンドオブジェクト
