## Why Unit tests

- なぜ単体テストするの？
  - 設計が良くなる？
    - 悪いことを検知できるだけで、いいかは別問題
    - 副産物にすぎない
  - **目的**
    - ソフトウェア開発プロジェクトの成長を**持続可能**なものにする
    - ソフトウェアエントロピーに抗う
- 全てのテスト・ケースは平等に作られてるわけではない
- **コードは資産ではなく負債**
  - 問題を解決するためのコードを最小限にすべき
  - ここには**テストコードも含まれる**
- 網羅率 coverage
  - 高い網羅率でも質が悪いことはあり得る
  - 率の出し方
    - コード網羅率
    - 分岐網羅率
  - **網羅率でテストスイートの質を評価できない理由**
    - フレームワークのコードの中身を全部見れてないよね？
    - 確認不在のテスト
      - 戻り値の確認をしてなかったり
  - 網羅率が低いことは、テスト・コードの質が悪いことを判断できる
    - が、高いからといって、**何もわからない**
- **テストスイートの質が良いことを自動的に評価できる方法は存在しない**
  - 個人的な判断に基づいて行われる
  - 優れたものの特徴
    - 開発サイクル中にテストされる
    - コードベースの特に重要な部分のみがテスト対象となっている
      - ビジネスロジック、ドメインモデル
    - 最小限の保守コストで最大限の価値を生み出す

## What is Unit tests

- 単体テストの性質
  - unit と呼ばれる少量のコードを検証する
  - 実行時間が短い
  - 隔離された状態で実行される
- 学派
  - 古典学派
  - ロンドン学派
    - モック主義者 とも呼ばれる？
- 隔離？
  - 古典学派
    - **テストケースが隔離されるべき、と考える**
    - 複数のクラスを同時に動かしても問題ない
    - **db などの共有依存はテスト・ダブルに置き換えることあり**
  - ロンドン学派
    - **テスト対象システムから協力者オブジェクトを分離する**
    - **テスト対象となるクラスが他のクラスに依存しているのであれば、その依存を全てテスト・ダブルに置き換えなければならない**
    - テスト・ダブル
      - リリース対象のオブジェクトと同じような見た目と振る舞いを持つ
      - 複雑さを減少させて簡潔にする
    - **値オブジェクト**は置き換える必要ない
    - **より実装の内部的なコードと結びつく**
- 依存
  - 共有依存
    - テストケース間で共有される依存
    - static な可変フィールド
  - プライベート依存
  - プロセス依存
- 揮発性依存
  - 開発マシンのデフォルトに加えて、**独自の設定を要求する場合**
    - db, api
  - 呼び出すたびに**異なる振る舞いをする**
    - ランダム、時間依存
- テストケースの役割
  - **テストに関わる人たちにテスト対象のコードが解決しようとしている物語を伝えること**
  - 凝集度 cohesion を高め、非開発者でも理解できるようにする
- 準備 (Arrange) フェーズがあまりにも大きくなるようであれば、何らかの設計の問題がある可能性が高い
- E2E テスト？
  - 結合テストよりも、多くのプロセス外依存を含む
    - 一般に結合テストは 1 or 2 個のプロセス外依存を扱う
    - E2E は全てのプロセス外依存を扱う
- **著者は古典学派の方が better だと考えている**

## Structure of Unit tests

- AAA パターン
  - Arrange
  - Act
  - Assert
- **単体テストで、同じフェーズが複数あるケースは許されない**
  - 結合テストなら可能性ある
- if 文をテストケースで書くのはダメ
  - 何もいいことないね
- **不変条件 invariant の侵害**
  - カプセル化で守る
- **テスト対象システムとその依存の区別**
  - SUT: System Under Test
    - sut 変数
- **テストはプロダクションコードが解決しようとしている物語 (story) について語るべき！**
- テストの命名
  - Bad
    - 実装の詳細に目をつけた命名
    - `Sum_TwoNumbers_ReturnsSum`
    - `IsDeliveryValid_InvalidDate_ReturnsFalse`
  - Good
    - 問題領域のことに精通している**非開発者**に対してどのような検証をするのか伝わる
    - `_` を使って単語を区切る
    - `Delivery_with_invalid_date_should_be_considered_invalid`
- テスト関数名にメソッド名を含めない
  - **コードをテストしてるのではなく、アプリケーションの振る舞いをテストしてるから**
  - SUT は振る舞いを起動するための単なる入り口に過ぎない
- `Delivery_with_invalid_date_should_be_considered_invalid` をより改善する
  - invalid??
    - => `past`
  - **should be は良くあるアンチパターン**
    - シナリオを伝えるべきではなく、希望や要望を含めるべきではないww
    - => `is_invalid`

## Good tests

- **良いテストの4本の柱**
  - 後退 (regression) に対する保護
  - リファクタリングへの耐性
  - 迅速なフィードバック
  - 保守のしやすさ
- 後退に対する保護
  - コードは資産ではなく負債
  - ちゅうもーく
    - テスト実行時に通る**プロダクションコードの量**
      - 基本的には多いほどいい
    - そのコードの**複雑さ**
    - そのコードが扱う**ドメインの重要性**
- リファクタリングへの耐性
  - 偽陽性 false positive
    - **テストコードをテスト対象の内部的なコードから切り離すことが大事**
    - テストケースが**物語を伝えているか**
      - NG: 実装の詳細と結びついてしまう
    - **テストコードが対象の実装と深く結びつくとリファクタリングへの耐性がなくなる**
- **テストコードを含む全てのコードは負債である**
- 取るにたらないテスト
  - **プロダクションコードと同じことを別の書き方で表現してるに過ぎないケース**
    - 退行に対する保護が全く備わってない
- テストピラミッド
  - regression に対する保護 <=> 迅速なフィードバック
  - E2E <=> Integration <=> Unit
  - どの層でもリファクタリングへの耐性は必ず備えるようにする
- 結合テストでは通常、テスト実施するプロセスはアプリをホストするプロセスと同じになる
- ホワイト vs ブラック
  - ホワイトボックステストだと、テストケースはテスト対象の内部的なコードと深く結びつく
    - **偽陽性のリスクが高まる**
  - **ブラックボックステストをまず選択する**

## mock and stub

- モック
  - SUT とその協力者オブジェクトとのやりとりを検証するのに使われるテスト・ダブルのこと
- テスト・ダブル
  - テストでしか使わない偽りの依存を包括的に意味するもの
  - 5 種類
    - モック
      - スパイ
      - モック
    - スタブ
      - ダミー
      - スタブ
      - フェイク
- モック
  - 外側に向かうコミュニケーション、つまり **出力の模倣**
  - **メール・サービスへの副作用**
  - **模倣 + 検証**
- スタブ
  - 内側に向かうコミュニケーション、つまり **入力の模倣**
  - **データベースへの fetch**
  - **模倣のみ**
- CQS: Command Query Separation
  - Command
    - 副作用を伴う
    - 戻り値なし
    - モック
  - Query
    - 副作用なし
    - 戻り値あり
    - スタブ
- **検証するのは WHAT であり HOW ではない**
- 理想とすべき API (module の振る舞い) 設計
  - **1つの操作で目標を達成できる**
- ヘキサゴナルアーキテクチャ
  - 考え方
    - ドメイン層とアプリケーション・サービス層との関心分離
    - アプリケーション内でのコミュニケーション方向
      - ドメイン層はアプリケーションに依存できない
    - 外部アプリケーションとのコミュニケーション
  - **ドメイン層とアプリケーション層はそれぞれ観測可能な振る舞いを提供**
- システム内・システム間コミュニケーション
  - システム内コミュニケーション
    - アプリケーション内のクラス間で行われるもの
    - 実装の詳細になる
  - システム間コミュニケーション
    - 外部システムとの通信
    - 後方互換を常に維持すること
    - モックの使い所
- **外部から観測できないプロセス外依存とのコミュニケーションは実装の詳細になる**
  - **そのコミュニケーションに対してものにを行う場合、同じデータ構造を持つことも同じ手順を踏むことも維持する必要はなくなる**
  - **=> このような依存はモックを使って検証すべきではない**
  - e.g.)
    - **テスト対象のアプリケーションからしかアクセスされないデータベース**
      - クライアントから完全に隠蔽されており実装の詳細になっているもの

## methods for testing

- テストの手法
  - 出力値ベーステスト
    - 最も質の高いテストを作成できる
  - 状態ベーステスト
  - コミュニケーションベーステスト
- 出力値ベーステスト
  - 処理の後、テスト対象システムの状態・協力者オブジェクトの状態が変わらない場合のみ
  - 関数型による単体テストの手法
- 状態ベーステスト
  - 処理の実行の後、テスト対象の状態を検証する
- 関数型アーキテクチャ
  - 関数型プログラミング
    - 純粋関数
      - 隠れた入力や出力がない関数
    - **隠れた入力や出力となる種類**
      - 副作用
      - 例外
      - 内部もしくは外部の状態への参照
  - **参照透過性 referential transparency** の確認
    - 振る舞いを変えることなくメソッドを呼び出してる部分を値に変えられるか
      - ？
  - **実際に副作用を0にすることは無理**
    - そのようなアプリは意味がない
- **ビジネスロジックを扱うコードと副作用を起こすコードを分離する**
  - **副作用をビジネスオペレーションの最初や最後に持っていく**
  - 分離
    - 決定を下すコード
    - 決定に基づくアクションを実行するコード
      - db 操作
  - **↑ の分離は class が分かれるイメージ**
- c.f. オブジェクト指向
  - オブジェクト指向
    - 可変の部分をカプセル化してコードを理解しやすく
  - 関数型
    - 可変の部分を最小限にしてコードを理解しやすく
- 関数型アーキテクチャ
  - バッチリハマるケース
    - 関数的核を呼び出す前に、全ての入力値を集めることができたから
