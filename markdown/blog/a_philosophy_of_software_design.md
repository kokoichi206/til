あまりにも表紙がカッコよかったので [『A Philosophy of Software Design』](https://www.amazon.co.jp/-/en/John-Ousterhout/dp/1732102201)を購入しました。

頑張って英語の本を読んだので、内容についてメモしておきます。

## Chap1. 導入

プログラミングは、創造的な心と思考を整理する能力が必要となる。システムが思い描けたのならば、コンピューターの言語で記述することは容易い。  
つまり、ソフトウェアを記述するときは、**システムへの理解が足りていないこと**が最大の欠陥ポイントとなる。  
ここを最大限カバーするため、この本では『**システムの複雑性を減らすこと**』を最大のゴールとして話を進めています。

複雑性を減らすために、次の**2 つのアプローチ**がある。

1. コードをシンプルで明白にする
2. 複雑性を隠蔽する(modular design)

ソフトウェアデザインは終わりのないプロセスであり、ソフトウェアが動いている間にわたって行われ続けるべきものである（この点において建築物などと大きく異なる）。  
また、最初に思い描いたデザインは大抵間違いが多いので、漸進的に改善し続ける必要があり（アジャイル開発）、これは言い換えると**ソフトウェアデザインは決して終わらない**ということである。

この本の 2 つの主題

1. 複雑性の本質とは
2. どのように複雑性と向き合うか

## Chap2. 複雑性の本質

まずは敵を知ろう。

複雑性（Complexity）とは、システムの『理解をしにくくしているもの』や『変更を難しくしているもの』である。

複雑性の兆候として、具体的に次の 3 つが挙げられる。

1. 変更箇所の増大
   - 簡単な変更を行うときですら、**多くの異なる箇 所（ファイル）の変更**が必要となる
   - 依存関係
2. 認知的負荷の増大
   - 開発者がタスクを完了させるにあたり、知らなければならない情報が多くなってしまうこと
   - 多くのメソッドの提供される API やグローバル変数、モジュール間の依存関係など
   - 曖昧さ
3. 未知の未知
   - 変更や考慮が必要な箇所（問題の存在自体）に気がついてない
   - バグが起きて初めて問題の存在に気がつく状態
   - 曖昧さ

複雑性は『**依存関係**』と『**曖昧さ**』から生じる。

依存関係はソフトウェアの本質部分であり、完全に排除することはできない。

重要な情報が明確になっていないときに、曖昧さは発生する（`time` などの汎用的な命名が情報を持たないように）。  
また、一貫性がないことやドキュメントが不足していることからも、曖昧さは発生する。

**複雑性の高まった未来**  
開発者は変更を安全に行うために多くの時間をかけて情報を集める必要があり、最悪の場合必要な情報を見つけることができない。

## Chap3. "Working Code" は十分ではない

プログラミングタスクに取り組むときのマインドセットは、ソフトウェアデザインで最も重要な要素の 1 つである。  
多くの企業は、早く機能を完成させる短期的な戦術（tactical）をとるが、より戦略的なアプローチを取る必要がある。

strategic（戦略的な）なアプローチは、投資をしているというマインドセットが必要である。  
strategic なアプローチの例としては、良いドキュメントを書くこと、欠陥を見つけたときに少し立ち止まって修正すること、などが挙げられる。

全体の 10-20% を投資的に改善に回すのが良いだろう。

ここに書いたことは**スタートアップなどのプロジェクトについても同様**である。  
strategic なアプローチは比較的早くペイオフするため、結果的にファーストリリースも早くなるだろう。

Facebook の例もあるように、実際はどちらの方法でも成功する可能性があるが、ソフトウェアデザインに拘った綺麗なコードの中で作業する方が面白いよね。

## Chap4. モジュールは深くするべき

ここでいうモジュールとは、クラス、サブシステムやサービスなど、さまざまな形をとる。

モジュールがまとまって機能するためには、お互いに何かしらの情報を知っている必要があり、これは依存関係そのものである。  
"modular design" の目標は、モジュール間の依存性を小さくすることである。

依存関係のコントロールのため、各モジュールを 2 つのパートで考える。  
『インターフェース』と『実装』である。インターフェースは、他のモジュールからそのモジュールを使うために開発者が知るべき情報全てである。

インターフェースには 2 種類あり、"formal" なものと "informal" なもの。"formal" なものはメソッドのシグナチャである。"informal" なものは、『引数のファイル名を削除する』など、より上位の振る舞いのことである。

抽象化は "modular design" の考えと非常に関係している。抽象化とは、ある物事から重要でない情報を省き簡略化することである。

抽象化が失敗するのは 2 種類あって、『重要ではない情報を含んでしまうこと』と『実は重要な情報を含んでしまうこと』。  
抽象化の際に大事なのは、何が重要なのかを理解し、重要な情報を表すパラメータが少なくなるよう設計すること。

最高のモジュールとは、強力な機能を提供しつつシンプルなインターフェースをしていること、である。このことを "deep module" と呼ぶ。

Unix I/O やガベージコレクションはよくできたモジュールの例。

選択肢を持たせることはいいことだが、**一般的なケースをなるべくシンプルに実現できる**のが良いインターフェースの設計である。

モジュールの実装とインターフェースを分けることで、他のシステムに対し実装の複雑さを隠すことができる。

## Chap5. 情報隠蔽（と漏洩）

モジュールの基本的な考えは、情報をカプセル化するべき、というものである。  
隠す情報というのは、データ構造やアルゴリズム等も含まれる。  
より多くの情報を隠せば、モジュールのインターフェースを簡潔にでき、モジュールをより深いものにできる。

"information hiding" と逆になる考えが "information leakage" である。  
デザイン設計が複数のモジュールを反映したものになるとき、情報の漏洩が起こる。

モジュールのインターフェースに現れなかったとしても情報はリークしうる。  
（例えば 2 つのモジュールが、同じファイルフォーマットの知識を持つなど）

ソフトウェアデザインをする上で最も重要なスキルは、**情報が漏洩していることに気がつくこと！**

最もよくあるユースケースなるべく簡潔にするよう、デフォルト値を設定することも大切。  
可能な限り、クラスは『明示的に聞かれずとも正しいことをやる』ようにするべきである。最も良い機能は、存在すら気づかれずに機能していることである。

情報を隠蔽することと深いモジュールは密接に関係している。

またモジュールに分割するときに、オペレーションが行われる順番に影響を受けるべきではない

## Chap6. 汎用的なモジュールは深くする

新しいモジュールを作るときに悩むのが、『一般の用途にするか（general-purpose）』『特別な用途にするか（special-purpose）』ということ。

将来必要になる形はわからない。また汎用的にしすぎると、今直面している問題を解くにはベストな形にならないかもしれない。

とりあえず特定の目的のためにクラスを分割し、さらに必要になれば汎用的にリファクタすることも可能。"special-purpose approach" が漸進的なソフトウェアプロセスにおいては適している。

おすすめは次のようにすること（somewhat general-purpose）  
機能は現在直面しているものを解決するようにするが、提供するインターフェースは汎用的なものにする。

『モジュールの利用において、誰がいつ何を知るべきかを決定すること』は、ソフトウェアデザインで最も重要なことの 1 つである。

現在の問題を網羅する、最も簡潔なインターフェースはなんだろう！？って考える

## Chap7. 異なるレイヤーには異なる抽象化を！

メソッドの中で、異なるクラスのメソッドを呼び出してるだけの関数が多すぎたら注意が必要。

内部の実装に使われる表現とインターフェースに現れる抽象化は異なるべきで、あまり違いがないようならそのクラスはあんまり深くない可能性がある。

## Chap8. 複雑性を下方に引き下げる

ほとんどのモジュールは、開発者よりも利用するユーザーの方が多いので、頭を悩ませるなら開発者の方にするべきである。  
そして重要なのは、シンプルな実装をするよりもシンプルなインターフェースにすることである。  
（例えばクラスが例外を投げてしまうと、全ての呼び出し元がそれに対応しないといけなくなってしまう）

例えばネットワーク接続において、一定時間応答がない場合に失敗として再接続を行うケースを考える。リトライ間の間隔を設定パラメータ・引数などとして取ることもできるが、成功時の時間を使って内部で計算することもできる。  
こういうこと。

すなわち、**なるべく設定パラメータは避けるべき！**  
設定パラメータを作成する前に、1回問いかけるべき『この場で計算するのではなく、ユーザーが設定できるようにするべきことなのか』

## Chap9. Better Together Or Better Apart?

2つの機能があったときに、それらは同じ場所にまとめて実装されるべきか・それとも別々の場所に分けて実装されるべきか、というのはよくある問いの1つである。
