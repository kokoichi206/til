## sec1

- Linux を構成する概念
  - ファイルシステム
  - プロセス
  - ストリーム


``` sh
$ gcc -dumpversion
9

gcc -o hello hello.c

# 警告オプションを全て有効にする。
gcc -o hello -Wall hello.c
```

``` c
// argv の型: char へのポインタの配列
int main(int args, char *argv[])
```

`"` はシェルの機能で、囲んだ部分を1つのコマンドライン引数にまとめる！！

- man コマンド
  - 最初に見つかったセクションのページを表示する
  - ページを指定するには
    - man 3 printf
  - section
    - 1: コマンドらいん
    - 2: システムコール 
    - 3: ライブラリ関数

## sec2

- OS
  - Linux ディストリビューション
    - シェル
    - util-lnux
    - procps
    - GNU coreutils
    - X Window System
    - GNOME, KDE
- UNIX
  - 著作権やライセンスの問題が根深く絡んでいる
  - Linux は UNIX 風 OS の一種だと考えてプログラミングできる
  - 1980
    - System V
    - BSD
      - macOS <- FreeBSD
- Linux の世界 = OS の事、ではない！
  - カーネルが作り出している世界のこと
  - **ルートディレクトリで ls した時のファイルが、カーネルのプログラム本体**
  - Linux とは OS のことだと考えられがちだが、厳密には**カーネルだけを指している**
- デバイスとデバイスドライバ
- システムコール
  - カーネルに頼み込んで仕事を依頼すること
  - ハードウェアとの直接のやり取りなど
  - システムコールこそが Linux カーネルの核心
- ライブラリ関数
  - システムコール以外に使える関数
  - ライブラリに収められているから
  - 関数を貸してもらう作業をリンクという
  - システムコールとの差は曖昧
- libc
  - Linux に用意亜sれているライブラリ
  - 標準 C ライブラリ

``` sh
$ ls /lib/aarch64-linux-gnu/libc.so.6 
/lib/aarch64-linux-gnu/libc.so.6
$ ls -l /lib/aarch64-linux-gnu/libc.so.6 
-rw-r--r-- 1 root root 1641496 Jul  6  2022 /lib/aarch64-linux-gnu/libc.so.6
```

- API
  - C のライブラリの API は関数やマクロ
  - Linux コマンドや設定ファイルが入ることも

## sec3

- ファイルシステム
- ファイルの区別
  - 広義のファイル
    - ディレクトリ
    - シンボリックリンク
    - デバイスファイル
  - 狭義のファイル（regular file）
  - ストリーム
- デバイスの後ろ盾がないデバイスファイル
  - dev null
  - dev zero
  - dev random
- プロセス
  - 動作中のプログラムのこと
  - プログラム
    - ファイルのような形態で存在しているデータも含む
  - 1つのプログラムがあればプロセスは幾つでも作れる
- シグナル
  - Ctrl + C
    - カーネルが該当プロセスに割り込みシグナルを送る
- ストリーム
  - 本書ではバイトストリームのことを指す！
  - バイト列が出たり入ったりするものであれば何でもストリーム！
- パイプ
  - ストリームの両端にプロセスが繋がったもの！！
  - ステップ
    - まず各コマンドを独立したプロセスとして同時に実行する
    - プロセス間をストリームで繋ぐ
- ネットワーク通信
  - ストリームが別のコンピュータにまで伸びたもの
- プロセス間通信
  - ストリーム
  - POSIX IPC
- ３大要素
  - ファイルシステム
    - データに名前をつけて保存する場所
  - プロセス
    - 活動をする主体
  - ストリーム
    - プロセスが他の fs やプロセスとデータをやり取りする手段

``` sh
$ mount -t ext4
/dev/mmcblk0p2 on / type ext4 (rw,relatime)

ps -ef
```

## sec4

- マルチユーザシステム
  - cf: マルチユーザシステムを採用していない
    - 少し前の iOS, Android
    - ログインが省けたり、権限管理も不要
- ディレクトリのパーミッション
  - 読み込み可能の場合、その中のファイル一覧を得られる
  - 書き込み可能の場合、その中に新しいファイルを作成したりできる
  - 実行可能の場合、そのディレクトリの中のファイルにアクセスできる
- クレデンシャル
  - ユーザーAとしてアクセスする = ユーザAの属性を持ったプロセスがアクセスする
    - Linux 上に置いて、活動する主体はユーザではなくプロセス！！！
  - 通常はログインにより証明書が渡される；

``` sh
cat /etc/passwd

cat /etc/group
```

- コマンドらいん
  - シェル
  - 端末
- 端末
  - 黎明期に使われていた端末たテレタイプ
    - 現在のようなディスプレイがなかったため、長い紙に出力されていた
  - ダム端末
  - キャラクタ端末
    - ASCII は元々キャラクタ端末に対する命令として作られていた
  - ビットマップディスプレイ
  - 端末エミュレータ
    - **元々ハードウェアであった端末を、全てソフトウェアにしてしまったもの！**
- 端末も例外なくファイル
  - `/dev/tty0`
  - ファイルとして扱うメリット
    - **表現されているものに接続するためのストリームが得られること！**
- シェル
  - ログイン時に起動されるという点を除くと、ストリームからコマンドを読み込んで実行するプログラムにすぎない！

## sec5

- ファイルディスクリプタ
  - プログラムから見るとただの整数値
  - **カーネルが持ってるストリームを番号と対応づけたもの**
- 3つのストリームがすでに用意されている
  - 標準入力、標準出力、標準エラー出力
- cat コマンドがファイルを意識することはない
- ストリームの読み書き
  - system call read(2)
    - ファイル終端 0
    - エラー発生 -1
  - 人間が読める文字列を格納する場合は `'\0'` で終端するのが習慣
  -  `'\0'` 終端を**前提とする** API
     - printf など
     - read では前提としない 
- ストリームの定義
  - ファイルディスクリプタで表現され read または write で操作できるもののこと
- open
  - flags
    - man 2 open
- close
  - ストリームを始末するシステムコール
- errno 変数
  - 成功なら 0 以上の整数を返す
  - 失敗なら -1 を返す
- perror
  - ライブラリ関数
- ファイルオフセット
  - ストリームをどこまで読んだかの記憶
- dup
  - ファイルディスクリプタを複製するシステムコール

``` sh
gcc -Wall cat.c
```

## sec6

- systemcall
  - 関数呼び出しよりずっと遅い！！
    - **1 KB 以上の単位でシステムコールを呼ばないと、効率は上がらない**
  - バイト数単位でしか呼べない
- stdio
  - 使いにくさをカバーして利便性を上げたもの
    - 独自のバッファを持っている
  - standard i/o library
    - 標準入出力ライブラリ
  - カーネルレベルのストリームに API の層を追加
  - open に対する fopen
  - close に対する fclose
- 行単位の入出力
  - fgets
- バッファオーバーフローを起こす危険がある関数
  - gets
  - scanf
- バッファリングの操作
  - fflush

## sec7

- head
  - コマンドライン引数でファイル名を渡すと、そのファイル先頭の数行を出力する
  - コマンドライン引数でファイル名を渡さなかった場合は標準入力から読み込む
- コマンドラインオプション
- Linux において『行』とは『'\n' で終わる文字列』のこと
- getopt
  - ショートオプションだけを認識する
  - 常にループと一緒に使う
  - 第三引数
    - オプションを並べて書く
    - パラメータを取るオプションがある時は、そのオプション文字の次にコロンをつける！！
  - GNU libc の getopt は仕様がかなり特殊
- getopt_long もあるよ
  - **getopt の全ての機能に加えて**、ロングオプションの解析も可能
  - https://man.freebsd.org/cgi/man.cgi?getopt_long(3)

### gdb

``` sh
gcc -Wall -g -o head head.c

gdb ./head

(gdb) run -n 5
(gdb) frame 3
(gdb) list
(gdb) print optarg
```

## sec8

- man ascii
- 文字コードの概念
  - 符号化文字集合
  - エンコーディング
- 符号化文字集合
  - CCS: Coded Character Set
  - 文字コードで表現可能な文字の範囲のこと
  - 日本語文字だと、主に次の2つが使われる
    - JIS X
    - UCS (ISO-10646)
- エンコーディング
  - 符号化文字集合に属す文字に、それぞれを特定するための番号が振られている
  - 実際のバイト列に落とす時の計算式がエンコーディング
  - CES: Character Encoding Scheme
    - EUC-JP, UTF-8 は正確にはこのエンコーディングを指す
- エンコーディングの大まかな分類
  - 全ての文字に対して同じバイト数を使うエンコーディング
    - ワイドキャラクタ
  - 文字の種類によって使うバイト数を変えるエンコーディング
    - マルチバイトキャラクタ
    - 一般的
- 国際化
  - あるアプリケーションを地域化できるようにすること
  - ロケール（ルカール）
    - C 言語で国際化の基礎となる仕組み
  - 国と言語と文字コードの組み合わせがロケール
    - `ja_JP.UTF-8`
    - ja が日本語
    - JP が日本という地域
    - UTF-8 が Unicode
  - ユーザーレベル
    - 環境変数 LANG
    - LC_ALL, LC_TIME

slice

こんな感じでやろうとしたけどできなかった。。。

``` c
matched = regexec(pat, buf, 1, matches, 0) == 0;
```

## sec9

- FHS: Filesystem Hierarchy Standard
  - ディレクトリツリーの標準規格
- ルートディレクトリなしでは Linux はブートすらできない
- `/bin` と `/usr/bin` はディストリビューションが管理するディレクトリ
  - 自分でインストールするコマンドは `/usr/local/bin` などに置くべき
- sbin
  - 管理者用コマンドを置く
- lib ディレクトリ
- usr ディレクトリ
  - 複数マシンで共有可能なファイルを置く
  - **User Services and Routines**
- var
  - 頻繁に書き換えられるファイルを置くために使う
  - /var/run
    - 起動中のサーバプロセスのプロセス ID が保存される
    - PID file
- tmp
  - tmp vs var/tmp
    - tmp ハリブートしたら消える可能性がある
    - var tmp はリブートしても消されない
      - vi のリカバリ用ファイルなど

## sec10

- ディレクトリ
  - 他の普通のファイルのような操作が可能
    - open
    - read
    - close
  - バイト列であるが、同時に構造体の列でもある！
- ディレクトリエントリ
  - ディレクトリエントリであることを押し出した API の方が使いやすい
- ls がソートされて出力されるのは ls の内部でやっている
  - systemcall とかのレベルでは区別ない
  - ls -U
- ディレクトリのトラバース
- mkdir
  - 他のシステムコールと比べてもかなり頻繁に失敗する
- unmask
  - unmask で変更した値が使われる
  - プロセス属性の1つで、最も一般の値は 0x022
  - `mode & ~unmask` で計算される
- ハードリンク
  - ファイルには名前がついていることが重要
  - Linux では1つのファイルに2つ以上の名前をつけることも可能
  - ハードリンク
    - シンボリックリンク特別したい時にハードリンクということが多いかも
    - **名前と実体を結び付ける**
        - ファイル a の実体に、新しい名前 b をつけてみる
  - ほとんど今では用途がない
- シンボリックリンク
  - **名前に名前を結び付ける**
  - シンボリックリンクにアクセスがあった時に、初めて名前から実体を割り出す
    - （毎回検索している）
  - ディレクトリにも別名が付けられる

``` sh
echo 'hogehoge' > a
ln a b

rm -f a b

# 2 列目はリンクカウント
# リンクカウントは実体に記憶される。
ls -l

# rm はファイルではなくファイル名を消す！！
# 実体を指す名前が全てなくなった時点で実体は削除される。
rm a
```

- ファイルの移動
  - 1つの実体に対する名前を付け替えることと大体同じ！
  - **別のハードリンクを作ってから元の名前を消す**
- 付帯情報の取得
  - stat
- 付帯情報の変更
  - chmod
  - chown
  - utime

## sec11

- 物理で見たコンピュータの構造
  - バスを中心に成り立つ
  - メモリ
    - 0, 1 を記憶できるデバイス
  - CPU
    - 内部にはレジスタと呼ばれる変数のような機構
    - レジスタにメモリからデータをコピー
    - 演算してまたメモリに戻す
  - デバイス
    - hdd, sdd
- 機械語
  - cpu はメモリ上にあるプログラムに従って動作する
  - CPU の種類ごとにバラバラ
- コンピュータアーキテクチャ
  - 機械語を中心としたコンピュータの設計方針
  - x86
  - arm アーキテクチャ
    - Android, iOS
    - 商品電力が少ない
- マルチタスク
  - プロセスが複数同時に動作可能
  - プロセス専用の CPU, メモリがあるように見せれば良い
    - 仮想 CPU
    - 仮想メモリ
- 仮想 CPU
  - 非常に短い単位時間ごとに、実行するプロセスを次々に切り替える
    - タイムスライス
    - スケジューラ（ディスパッチャとも呼ばれる）
- 仮想メモリ
  - 単純に分割すればいいってことではない
  - 論理アドレスと物理アドレスに分ける
  - アドレス空間の分割
  - 一旦 4KB, 8KB などのサイズの**ページに分割される**
  - 論理アドレスには必ずしも物理アドレスを割り当てる必要はない
    - アドレス空間は実際のメモリ容量より大きくなる
    - 2-64 GB の実メモリに対し、172 億 GB ほどになる！
      - 64 ビット符号なし整数で表せる最大の領域
- 64 ビットアーキテクチャ
  - 64 ビットのアドレス空間
  - 64 ビットのレジスタを持つコンピュータアーキテクチ
- 仮想メモリ機構
  - ページング: paging
    - HDD, SSD などのストレージを物理メモリの代わりに使う機構
    - **プロセス全体**を単位に退避をすることを、**スワッピング**、という
  - メモリマップファイル: memory mapped file
    - ファイルをメモリとしてアクセスできるようにする仕組み
    - 仕組みはページングと逆
    - mmap
  - 共有メモリ: shared memory
    - 指定範囲の物理メモリを**複数プロセスで共有**する機構
    - System V 共有メモリ
    - POSIX 共有メモリ
- アドレス空間の構造
  - テキスト領域
    - 機械語のプログラム
  - データ領域
    - グローバル変数とか
  - BSS 領域
  - ヒープりょういき
    - malloc が管理
    - 実行時に拡大・縮小しうる
  - スタック領域
    - 関数の引数やローカル変数

``` sh
ls /proc/225520/maps
```

- C 言語でメモリを確保する方法
  - malloc
    - ヒープ領域から取る
    - 動的なメモリ割り当て
  - 静的なメモリ割り当て
    - **静的 = プログラムビルド時に決定が可能**
    - **グローバル変数やスタティック変数**
  - alloca
    - スタック領域から動的に割り当てる
- malloc
  - size バイトのメモリをヒープ領域に割り当てて、その先頭へのポインタを返す
- free
  - 一旦 free で解放したら、そのメモリにアクセスしてはいけない
- brk, sbrk
  - **まだ物理アドレスが割り当てられていないページに物理アドレスを対応させる！**
- ビルドの中身
  - プリプロセス
    - include, ifdef, define を処理して純粋な C 言語のソースコードにする
    - gcc -E
  - コンパイル
    - アセンブリ言語のソースコード (*.s) に変換する
  - アセンブル
    - アセンブリ言語のソースコードを機械語を含むオブジェクトファイル (*.o) に変換する
    - gcc -c
  - リンク
    - 実行ファイル or ライブラリを生成する
    - ELF フォーマットなど
    - スタティックリンク
      - あんま使われない
    - ダイナミックリンク
      - *.so, libc.so.6
      - リンクローダ
- dlopen

``` sh
man dlopen
```

## sec12

- fork
  - 自プロセスを複製してプロセスを作る
  - 複製前と後のプロセスは、どちらも fork を呼び出した状態になて散る
  - 親プロセスは子プロセスのプロセス id が戻り値
  - 子プロセスは戻り値 0
- exec
  - 自プロセスを新しいプログラムで上書きする
  - fork + exec
  - execXxx, exec 族
- wait
  - fork したプロセスの終了を待つ
  - wait or waitpid
- ライブラリ関数の system(3)
  - 簡単に spawn を書けるようになる
  - シェルを起動するので負荷は高い
  - セキュリティ上の問題にも繋がりやすい
- `_exit(2)`
  - プロセスを自発絵tきに終了する
- `exit(3)`
  - ライブラリ関数
- ゾンビプロセス回避
  - fork したら wait する
  - ダブル fork
  - sigaction を使う
- パイプ
  - プロセスからプロセスに繋がったストリームのこと
  - パイプもファイルディスクリプタを使って表現される
  - 他のストリームと違ってパイプは一方向！
  - fork は複製時にストリームも全て複製する！！
    - 親が読み込み側を close
    - 子が書き込み側を close
- dup, dup2
  - 狙った fd にパイプを繋ぐために必要
  - ファイルディスクリプた oldfd を複製する
  - 3 番のパイプを 0 番に移す
    - close(0)
    - dup2(3,0)
    - close(3)
- popen
  - stdio
  - もう少し扱いやすいパイプ接続用 API
- プロセスの親子関係
  - pstree
  - systemd
  - getpid
  - getppid
  - ps j
  - ps -ef
    - マシン上の全プロセス
    - **制御端末を持たないプロセスをデーモンプロセス**、デーモンという

[fork(wiki)](https://ja.wikipedia.org/wiki/Fork)

> forkが呼び出されると、子プロセスのためのアドレス空間が新たに作成される。子プロセスのアドレス空間には親プロセスが持っていた全セグメントのコピーがあるが、コピーオンライト機能によって実際の物理メモリの確保は遅延される（すなわち、一時的に同じ物理メモリセグメント群を親子で共有する）。

Copy-on-Write

## sec13

- シグナル
  - マクロで名前がつけられた int 型
- コアダンプ
  - core dump
  - プロセスのメモリのスナップショットのこと
  - core というファイルに保存される
  - core はメモリを指す！
    - コアメモリ（磁気コア）を昔は使っていた
- シグナル
  - SIGPIPE
    - 切れたパイプに書き込むと生成される
  - SIGCHLD
    - 子プロセスが停止または終了したときに生成される
- シグナル**補足**インタフェース
  - signal
  - 関数ポインタ！とか出てきた！
  - シグナルハンドラ
  - `void (*f)(int)` は「int を引数にとり戻り値のない関数」を指すポインタ！
- signal のいまいちな問題点を解決したもの！
  - sigaction
- シグナルの送信
  - kill
  - sendsig とかの方が良かったね
- cooked モード
  - **特殊な働きをするキー！**
  - stty -a
- パイプで繋がれたプロセス群は1つのプロセスグループになる

``` sh
trap 'echo signal_SIGCHLD' SIGCHLD;
```

## sec14

- プロセスの属性
  - カレントディレクトリ
  - くれ電車る
  - 環境変数
  - 使用リソース
- getcwd (3)
  - library calls
  - パスが bufsize バイト以上になる時はエラー RANGE を返す
  - getwd はバッファオーバーフローの危険があるので使わない！
- chdir
  - 自プロセスのカレントディレクトリを変更する
- 環境変数: environment variable
  - **プロセスの親子関係を通じて伝播するグローバル変数**のようなもの
  - PATH, EDITOR
  - **常に設定しておきたいユーザ独自の設定などをプログラムに伝える**
  - LESS
    - https://qiita.com/delphinus/items/b04752bb5b64e6cc4ea9#%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0-less
  - MORE, GZIP などにも
  - プログラムが意識する環境変数はたいてい各コマンドの man ページなどに記載されてる
  - よくある環境変数
    - PATH, TERM, LANG, LOGNAME, TEMP, PAGER, EDITOR, MANPATH, DISPLAY
- environ
  - 環境変数にはグローバル変数 environ を介してアクセスできる
  - `char**`
  - environ, getenv は使いまわしてはいけない
    - 後で変更される可能性があるため（putenv）
- set-uid
  - コマンドを実行するユーザに関係なく、特定のユーザの権限で実行したいケースがある
    - passwd など
  - ファイルパーミッションの set-uid ビット
    - 起動したユーザに関わらず、プログラムファイルのオーナー権限で起動される
  - real user ID
    - 起動したユーザーの ID
  - effective user ID
    - set-uid プログラムのオーナーの ID
- 別のクレデンシャルに移行する
  - setuid, setgid, initgroups の3つをセットで使う
  - 別ユーザになるステップ
    - 1. スーパーユーザとしてプログラムを起動する（してもらう）
    - 2. なりたいユーザのユーザ名と ID, グループ ID を得ておく
    - 3. setgid
    - 4. initgroups
    - 5. setuid
- プロセスの使うリソース
  - CPU, メモリ, バスなど
  - カーネルは各プロセスが使っているリソースの量をつど記録している
- getrusage
  - さまざまなリソース使用量が得られる！
  - man getrusage
- **時間の概念**
  - システム時間
    - **プロセスのためにカーネルが働いた時間**
    - システムコールを実行した時間
  - ユーザ時間
    - システム時間以外の、プロセスが完全に自分で消費した時間
- 日時と時刻
  - UNIX エポック
    - 32 bit 整数で秒を表すと 2038 年までしか表せられない

``` sh
export LESS='-g -i -M -R -S -W -z-4 -x4'

# set-uid プログラムの例！
# s がたっている → 誰が起動しても root 権限で起動される。
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 63744 May 28  2020 /usr/bin/passwd
```

- ログイン
  - 起きてること
    - 1. systemd または init が端末の数だけ getty コマンドを起動
    - 2. getty コマンドは端末からユーザ名が入力されるのを待ち、login コマンドを起動
    - 3. login コマンドがユーザを認証
    - 4. シェルを起動
- systemd
  - カーネルが直接起動する唯一のプログラム
    - 全てのプロセスの祖先
  - **+ getty というプログラムを起動する役割**も持つ
    - 端末を open, read してユーザ名をタイプするのを待つ
- 認証？
  - 現在はパスワードを etc/passwd に直接かかず /etc/shadow に分離したりしてる
    - シャドウパスワード
- **PAM**
  - Pluggable Authentiaction Module
  - ユーザを認証するという API
  - 実態は共有ライブラリ
    - ダイナミックロードを使って分割されている
- ログインシェル
  - "/bin/sh", "-sh" など、コマンド名の頭に `-` をつけて起動すること！！
  - 読み込む設定ファイルが増えたり、起動したりコマンドの扱いが変わったりする！！
- ログインの記録
  - w, last のようなコマンド

## sec15

- **マシン内だろうがネットワーク越しだろうが、相手にするのはストリーム！**
  - ストリームであれば　read, write で扱える
- open はどのようにするか
  - ネットワークにつながるコンピュータには、通信を待ち受けるプロセスが存在
    - これがファイルに対応する実体
- インターネット
  - サーバプロセス
  - クライアントプロセス

``` sh
cat /etc/services
```

- IP
  - IP の世界にストリームはない
  - **パケットのみ！**
    - 自分宛なら受け取る
    - それ以外なら転送する
- TCP
  - IP の上に層を重ねることで、**ストリームに見えるように**している
- ドメイン
  - root domain
  - TLDs
- リゾルバ
  - libc にある
  - /etc/nsswitch.conf
- ソケット
  - ネットワーク通信に使うもの
  - **ストリームをそこに接続することのできる口**
  - プロセスの先にくっついてるイメージ
  - 汎用性高い
    - TCP, UDP, 生の IP
    - インターネット以外
    - IPv4, IPv6
- クライアント側のソケット API
  - socket(2)
  - connect(2)
- connect
  - ソケット sock からストリームを伸ばし、アドレス addr で示すサーバーにストリームを接続する
  - **ホスト名ではなく IP アドレスとポート番号！**
- サーバー側のソケット API
  - socket(2)
  - bind(2)
  - listen(2)
  - accept(2)
- bind
  - 接続を待つアドレス addr をソケット sock に割り当てる
- listen
  - ソケット sock がサーバ用のソケット = **接続を待つためのソケットであることをカーネルに伝える！**
  - コネクションの最大数の設定など
- accept
  - sock にクライアントが接続してくるのを待ち、接続が完了したら接続済みストリームの fd を返す
- 名前解決
  - getaddrinfo
    - addinfo は malloc で割り当てられている → 明示的に解放が必要
  - getnameinfo
- インターネットスーパーサーバー
  - inetd, xinetd

``` sh
sudo apt install xinetd

cat /etc/xinetd.d/daytime

# disable = yes -> no
vim /etc/xinetd.d/daytime

sudo systemctl reload xinetd


grep daytime /etc/services

netstat --tcp --listen

gcc -g -Wall -o daytime daytime.c

$ ./daytime 
02 NOV 2023 19:37:52 UTC
$ ./daytime localhost
02 NOV 2023 19:41:15 UTC
```

``` sh
$ telnet localhost 13
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
02 NOV 2023 19:58:14 UTC
Connection closed by foreign host.
```

## sec16

- HTTP サーバー
  - ネットワーク、ストリーム、ファイルシステム、プロセス
  - HTML の中身を全て渡された時点で TCP ストリームが切断される
- HTTP
  - 常に "\r\n" (CR LF) を改行として扱う
  - ドキュメントルートとドキュメントツリー

## sec17

- 目指すところ
  - 自力でのソケット接続
  - デーモン化
  - syslog を使ったロギング
  - chroot を使ったセキュリティ向上
  - クレデンシャル変更のサポート
  - コマンドラインオプション解析
- ゾンビ問題の解決手段
  - シグナル SIGCHLD を受けた時に wait を呼ぶ
    - 正統派の対策
  - 一切 wait をしないことにする
    - sigaction を使って、自分は wait しないとカーネルに宣言する
- プリフォークサーバ
  - 最初に何回か fork しておき、子プロセスが accept する
    - 実装・運用難易度が高い
  - cf: 並行サーバ
    - accept してから fork する
- マルチスレッド
  - プリフォーク以外の高速化の手段
  - マルチスレッドセーフ
    - libc などの古くからあるライブラリではマルチスレッドセーフではない API が多くある
    - xxx_r という名前で、マルチスレッドセーフなバージョンが用意されることも多い
- デーモンになる
- chroot
  - ファイルシステムの隔離
  - ソケットも X もない時代の 1979 から存在していた
- cgroups
  - プロセス群に対する CPU, memory の管理ができる！
  - 独立した環境（コンテナ）を作れる
    - ファイルシステムも CPU, memory も io もネットワークも、単独の OS が動作しているように見せさせられる
    - アプリケーションの完全かつポータルな実行環境
  - コンテナの最新の実行形態が Docker
