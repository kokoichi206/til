## sec 1

- カーネル
  - 命令の実行順序の正しい制御
    - 最悪文鎮化 (brick)
  - CPU のモード
    - カーネルモードとユーザーモード
- システムコール
  - プロセスがカーネルに処理を依頼するための方法
  - システムに搭載されている論理 CPU が実行している命令の割合 → sar コマンド
  - sar
    - system はシステムコールを処理している時間の割合

``` sh
# -P 0 論理 CPU0 のデータ
# 1 1 秒ごとに
# 1 1 回だけ
sar -P 0 1 1
```

- ライブラリ
  - 標準 C ライブラリ
    - glibc
    - libc
  - プログラムがどのようなライブラリをリンクしているかは ldd コマンドで見れる！

``` sh
ldd /bin/echo

        linux-vdso.so.1 (0x0000ffffba162000)
        libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffb9f50000)
        /lib/ld-linux-aarch64.so.1 (0x0000ffffba129000)
```

- システムコールのラッパー関数
  - libc は標準 C のライブラリでだけではない
  - **システムコールは通常の関数呼び出しと違って C 言語などの高級言語から直接呼び出せない！**
    - **アーキテクチャ依存のアセンブリコードを使って呼び出す**必要がある
- 静的ライブラリか共有ライブラリか
  - サイズと ldd コマンドの実行結果
  - 共有ライブラリが今までは好んで使われてきた
  - 一方 **Go 言語は基本的にライブラリを全て静的リンクにしている！**
    - メモリやストレージの大容量化によってサイズの問題は相対的に小さくなった
    - プログラムが1つの実行ファイルだけで動けば、当該ファイルをコピーするだけで別の環境でも動作するので扱いが楽
    - 実行時に共有ライブラリをリンクしなくて済むので起動が高速
    - 共有ライブラリの DLL 地獄と呼ばれる問題を回避できる
